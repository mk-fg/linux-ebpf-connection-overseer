#!/usr/bin/env python

import ctypes as ct, socket as so, ipaddress as ip
import os, sys, re, struct, platform, time


class adict(dict):
	def __init__(self, *args, **kws):
		super().__init__(*args, **kws)
		self.__dict__ = self

p = lambda *a,**kw: print(*a, **kw, flush=True)
p_err = lambda *a,**kw: print(*a, **kw, file=sys.stderr, flush=True) or 1
err_fmt = lambda err: f'[{err.__class__.__name__}] {err}'


class BPFMapIDRingBuffer:
	_libbpf = None # needed for ringbuf_process_ring asm to process data
	class _rb_struct(ct.Structure): pass
	_rb_handler_t = ct.CFUNCTYPE(ct.c_int, ct.c_void_p, ct.c_void_p, ct.c_size_t)


	def __init__(self, fd=None, path=None):
		if not (cls := BPFMapIDRingBuffer)._libbpf:
			lib = cls._libbpf = ct.CDLL('libbpf.so.1', use_errno=True)
			lib.ring_buffer__new.argtypes = (
				ct.c_int, self._rb_handler_t, ct.c_void_p, ct.c_void_p )
			lib.ring_buffer__new.restype = ct.POINTER(self._rb_struct)
			lib.ring_buffer__poll.argtypes = ct.POINTER(self._rb_struct), ct.c_int
			lib.ring_buffer__poll.restype = ct.c_int
			lib.libbpf_set_strict_mode(0xffffffff) # LIBBPF_STRICT_ALL
		self.updates, self.handler = list(), self._rb_handler_t(self._ev_handler)
		self.rb = self._libbpf.ring_buffer__new(fd, self.handler, None, None)
		if not self.rb: raise OSError('Failed to init libbpf ring-buffer struct')

	def __enter__(self): return self
	def __exit__(self, *err): self.close()
	def close(self):
		if self.rb: self._libbpf.ring_buffer__free(self.rb); self.rb = None

	def _ev_handler( self, ctx, ev, n, _fmt='<BQ16s16sHHII16s',
			_fields='ct ns saddr daddr sport dport pid uid comm'.split(), _ct_map=[ None,
				('tcp', so.AddressFamily.AF_INET, 4), ('tcp', so.AddressFamily.AF_INET6, 16),
				('udp', so.AddressFamily.AF_INET, 4), ('udp', so.AddressFamily.AF_INET6, 16) ] ):
		self.updates.append(ev := adict(zip( _fields,
			struct.unpack_from(_fmt, bytes((ct.c_char*n).from_address(ev))) )))
		ev.proto, ev.af, n = _ct_map[ev.ct]
		# p(ev.saddr, ev.daddr)
		for k in 'saddr', 'daddr': ev[k] = ip.ip_address(ev[k][:n])
		ev.comm = ev.comm.rstrip(b'\0').decode()
		return 0

	def wait(self, timeout=1.0):
		self.updates.clear()
		if self._libbpf.ring_buffer__poll(
			self.rb, int(timeout*1000) ) <= 0: return () # timeout/error
		return tuple(self.updates)


def main(argv=None):
	import argparse, textwrap
	dd = lambda text: re.sub( r' \t+', ' ',
		textwrap.dedent(text).strip('\n') + '\n' ).replace('\t', '  ')
	parser = argparse.ArgumentParser(
		formatter_class=argparse.RawTextHelpFormatter,
		description='eBPF map parser script.')
	opts = parser.parse_args(sys.argv[1:] if argv is None else argv)

	sd_pid, sd_fds = (
		os.environ.get(f'LISTEN_{k}', '') for k in 'PID FDNAMES'.split() )
	if not sd_pid.isdigit() or int(sd_pid) != os.getpid():
		parser.error('systemd env LISTEN_PID does not match this process')
	sd_fds = (
		adict((k[:-4], 3+n) for n, k in enumerate(sd_fds.split(':')) if k.endswith('__v1'))
		if all(re.search(r'__v\d$', k) for k in sd_fds.split(':')) # versioned fds
		else adict((k, 3 + n) for n, k in enumerate(sd_fds.split(':'))) )

	if sd_sock := os.environ.get('NOTIFY_SOCKET'):
		if sd_sock[0] not in ('/', '@'): parser.error('Unsupported sd_notify socket')
		if sd_sock[0] == '@': sd_sock = '\0' + sd_sock[1:]
		with so.socket(so.AF_UNIX, so.SOCK_DGRAM | so.SOCK_CLOEXEC) as s:
			s.connect(sd_sock); s.sendall(b'READY=1')

	rb = BPFMapIDRingBuffer(sd_fds.updates)
	# maps = adict( (name[:-4], BPFHashMap(fd))
	# 	for name, fd in sd_fds.items() if name.endswith('_map') )

	ts0 = time.monotonic()
	while True:
		for ev in rb.wait(60): p(f'{time.monotonic() - ts0:.1f} {ev}')
		# rb.close(); break

if __name__ == '__main__': sys.exit(main())
